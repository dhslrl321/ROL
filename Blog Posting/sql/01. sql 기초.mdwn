### sample data

```sql
CREATE TABLE `buytb1` (
  `num` int NOT NULL AUTO_INCREMENT,
  `userId` char(8) NOT NULL,
  `prodname` char(6) NOT NULL,
  `groupname` char(4) DEFAULT NULL,
  `price` int NOT NULL,
  `amount` smallint NOT NULL,
  PRIMARY KEY (`num`),
  KEY `userId` (`userId`),
  CONSTRAINT `buytb1_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `usertb1` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

CREATE TABLE `usertb1` (
  `userId` char(8) NOT NULL,
  `name` varchar(10) NOT NULL,
  `birthYear` int NOT NULL,
  `addr` char(2) NOT NULL,
  `mobile1` char(3) DEFAULT NULL,
  `mobile2` char(8) DEFAULT NULL,
  `height` smallint DEFAULT NULL,
  `mdate` date DEFAULT NULL,
  PRIMARY KEY (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

insert into buytb1 values(NULL, "KBS", "운동화", null, 44, 1);
insert into buytb1 values(NULL, "KBS", "노트북", "전자", 2230, 1);
insert into buytb1 values(NULL, "JYP", "모니터", "전자", 630, 1);
insert into buytb1 values(NULL, "KBS", "상의", "의류", 80, 2);
insert into buytb1 values(NULL, "BBK", "충전기", "전자", 15, 3);
insert into buytb1 values(NULL, "EJW", "바지", "의류", 32, 2);
insert into buytb1 values(NULL, "SSK", "운동화", null, 50, 10);
insert into buytb1 values(NULL, "KBS", "휴대폰", "전자", 1100, 5);
insert into buytb1 values(NULL, "YJS", "자료구조책", "서적", 430, 1);
insert into buytb1 values(NULL, "JYP", "알고리즘책", "서적", 230, 22);
insert into buytb1 values(NULL, "JYP", "청바지", "의류", 320, 3);
insert into buytb1 values(NULL, "EJW", "아이패드", "전자", 10, 1);
insert into buytb1 values(NULL, "SSK", "책", "서적", 130, 22);
insert into buytb1 values(NULL, "SSK", "운동화", null, 630, 5);
```

# select

- `select .. from .. where` 특정 조건 조회
- `select .. from .. where .. between .. and ..`

## BETWEEN A AND B

특정 A와 B 사이의 값 조회하는데, **연속적인 값**에만 해당이 된다.
예를 들어서 키를 저장하는 height column이 있다면 다음과 같이 설정할 수 있다.

```sql
select name from usertb1 where height between 180 and 183;
```

그럼 180에서 183은 연속적인 값이므로 **between** 속성이 사용가능하다.

하지만 지역을 저장하는 addr이라는 칼럼이 있다면 **between** 속성 대신 **or** 속성을 사용해야한다.

```sql
select name from usertb1 where addr = '경남' or addr = '전남' or addr = '경북';
```

## IN()

위에서 봤듯 연속적이지 않는 값들을 사용할 때는 조금 불편할 수 있다.
이런 점을 보완하기 위해서 탄생한 것이 바로 **이산적인 값을 위한 IN()**이다.

```sql
select name from usertb1 where addr = '경남' or addr = '전남' or addr = '경북';
```

을 in()을 사용해서 더 깔끔하게 할 수 있다.

```sql
select name from usertb where addr in('경남', '전남', '경북');
```

## LIKE

name에 김씨를 찾으려면 LIKE와 같은 문자열 검색 연산자를 이용한다.
2가지 Like 연산자의 키워드가 있다.

- 무엇이든 허용 `%`;
- 한 글자와 매칭 `_`;

```sql
select name from usertb1 where name like "김%";
```

이렇게 되면 김으로 시작되는 모든 문자열을 검색한다.
이름은 물론이고 **김은 참 맛있네요**라는 문자열도 김으로 시작하므로 검색된다.

```sql
select name from usertb1 where name like "김__";
```

`_`는 한 문자와 매칭된다.
그래서 위의 sql문은 김OO인 사람은 모두가 검색되지만 **김은 참 맛있네요**처럼 조건에 맞지 않는 문자열은 검색되지 않는다.

## 서브 쿼리

서브 쿼리는 **쿼리문 안에 쿼리문**을 작성하는 것을 뜻한다.
예를 들어서 우리는 김경호라는 사람보다 키가 큰 사람들 모두를 찾고싶다.
그럼 직접 김경호의 키를 확인한 뒤 쿼리문을 다음과 같이 작성해야한다.

```sql
# 우선 김경호의 키를 찾자.
select height from usertb1 where name = '김경호';

# 김경호의 키를 찾았으니 해당 키보다 더 큰 사람들을 찾자.
select name, height from usertb1 where height > '172';
```

이렇게 2번 쿼리문을 사용해야만 한다.
하지만 이것을 서브쿼리문을 이용한다면 쉽게 줄일 수 있다.

```sql
select name, height from usertb1 where height > (
	select height from usertb1 where name = '김경호');
```

하지만 이런 서브쿼리에도 제약사항이 존재한다.

**서브쿼리는 하나의 값만 반환해야한다.**

이런 서브쿼리 제약을 유연하게 사용하는 방법이 바로 **ANY/ALL/SOME**이다.

## 서브 쿼리와 **ANY/ALL/SOME**

### ANY

ANY는 조건 a나 b중 하나만 적용되면 되는 **OR**과 같은 성격을 갖는다.
추가적으로 SOME도 ANY와 동일하게 사용된다.

### ALL

조건 하나만 적용되는 ANY와는 다르게 ALL은 모두 포함되어야 하는 **AND** 성격을 지닌다.

# ORDER BY

SELECT와 마찬가지로 DB에 직접적으로 영향을 미치지 않지만 결과가 출력되는 **순서**를 조절하는 구문이다.

- `select .. from .. order by ..` 특정 조건을 오름차순으로 출력
- `select .. from .. order by .. desc` 특정 조건을 내림차순으로 출력

```sql
select * from usertb1 order by height desc;
```

위와 같이 사용할 수 있다.

order by를 **select, from, where, group by**와 사용할 때는 항상 제일 뒤에 위치해야한다.

order by는 어려운 내용이 아니므로 이쯤하고 넘어가자.

# DISTINCT

중복된 것들을 제거하는 명령어가 바로 DISTINCT이다.

```sql
select distinct addr from usertb1;
```

# LIMIT

출력하는 개수를 제한하는 쿼리문이 바로 LIMIT이다.
예를 들어 아까 배웠던 order by로 입사일이 가장 오래된 사람순으로 정렬을 했다고 해보자.

```sql
select name, mdate from usertb1 order by mdate;
```

에서 상위 4명만 보고싶다면

```sql
select name, mdate from usertb1 order by mdate limit 5;
```

로 지정할 수 있다.

혹은 offset을 직접지정할 수 있는데, 아래와 같이 수행하면 3번째에서 그 다음 5번째만 출력하게 한다.

```sql
select name, mdate from usertb1 order by mdate limit 3, 5;
```

이런 LIMIT를 이용하면 DBMS의 성능을 향상시킬 수 있다.
