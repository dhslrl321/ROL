# 완전 탐색 종류

- 브루트 포스
- 건너 뛰며 해보기
- 비트 마스크
- 백트래킹
- 재귀함수
- 순열
- BFS
- DFS

#### 예를 들어서 `a + b + c + d = 20` 을 만족하는 네 수를 찾아라 (0 <= a, b, c, d, <= 100)

- 브루트 포스
  - 브루트포스는 가능한 모든 경우 1 ... 100 까지 다 해보면서 해강 값이 만족하는지를 탐색
  - 조건만 맞으면 100% 찾아냄
  - 자원이 매우 많이 필요
- 백트래킹
  - 노드의 유망성을 판단해, 해당 범위 내에 조건을 추가
  - 만약 a + b + c 노드의 합이 10 이라면 d 노드는 10 이상을 절대 넘지 않을 것으로 봄
  - 그래서 10 이상을 탐색하지 않음
  - 브루트 포스와 다르게 자원을 효율적으로 이용할 수 있음

# 브루트 포스

- 가능한 모든 경우의 수를 탐색하며 **요구 조건**에 충족되는 결과만을 가져옴.
- 예외 없이 100% 확률로 정답만 출력함
- 모든 문제를 해결할 수 있는 방법은 아님
- 모든 경우의 수를 다 해봐도 시간 제한을 넘지 않을 경우에 브루트 포스를 선택함
- 핵심은 가능한 모든 방법의 범위를 찾는 것
  - 리모컨 문제와 같은 경우도 1 ~ 100만까지 하나씩 다 해봄으로 해결

### 문제 해결 방법

1. 문제의 가능한 경우의 수를 다 계산해본다. (문제를 풀 수 있는 방법을 생각해본다.) : **직접 계산을 통해서 구한다.(손으로 계산해보기)**
2. 가능한 모든 방법을 만들어본다. (그 방법을 어떻게 만들 것인가) : **for문으로 반복하거나 순열, 비트마스크, 재귀등 다 해보자.**
3. 각각의 방법을 이용해 답을 구해본다. (그 방법을 이용해서 실제로 코드를 작성) **위에서 만든 방법을 통해서 최적 알고리즘을 검증**

### 예제 문제

- 백준 [1476번 날짜 계산](https://www.acmicpc.net/problem/1476)
- 백준 [3085번 사탕 게임](https://www.acmicpc.net/problem/3085)
- 백준 [1107번 리모컨](https://www.acmicpc.net/problem/1107)
- 백준 [14500번 테트로미노](https://www.acmicpc.net/problem/14500)

# 건너 뛰며 해보기

- 브루트 포스에서 조금 더 효율화 작업을 거친 알고리즘
- 하지만 모든걸 다 해보는 브루트포스와 다르게 점진적으로 건너뛰면서 실행해보는 기법
- 건너 띄는 부분은, 누가 봐도 이건 중복이다 혹은 필요 없다 싶은 부분을 건너 띄어야 함
- 보통 브루트 포스로 문제를 풀기엔 조금 벅찬 시간 복잡도를 갖는 문제에 적용
- 규칙을 찾아서 해당 규칙을 띄어 넘으며 해결
- 건너 띌 규칙을 찾는게 핵심인 문제

# 백트래킹

백 트래킹 알고리즘은 상태 공간을 트리로 나타낼 수 있을 때 사용하는 방식이다.

백트래킹은 기본적인 브루트 포스와 컨셉이 비슷한데, 다른 점이 하나 있다면 **브루트포스 알고리즘은 가능한 모든 경우를 대입해 정답을 찾는 방법**이지만 백트래킹은 **노드의 유망성**을 파악해 **유망한 노드만 탐색**하는 조금 진화된 기법이라고 할 수 있다.

### 노드의 유망성

노드의 유망성은 일종의 가지치기라고도 불리며 흔한 예로는 dfs에서 흔한 예로 dfs에서 방문 했는지를 확인하는 `boolean[] check` 에 해당한다.
dfs 탐색에서 노드의 유망성을 확인하고 만약 유망하지 않은 노드라면 해당 탐색은 더 깊게 들어가지 않고 다른 탐색으로 진행하게 된다.

### 문제 해결 방법

일종의 트리 탐색 알고리즘으로 **DFS, BFS, Heuristic Search** 등의 탐색이 일반적이다.

모든 경우의 수를 고려하는 문제에는 DFS가 BFS보다 조금 더 빠르게 나올 수 있으며 큐를 사용하는 BFS의 특성에서 잘못하면 큐의 크기가 엄청나게 커질 수 있다.
그래서 대부분 백트래킹에서는 DFS를 주로 사용한다.

하지만 DFS를 사용하면 안되는 조건도 존재한다.
예를 들어 상태 공간의 트리 깊이가 얼마나 깊은지 모를 경우에는 스택 오버플로우가 발생할 수 있다.
그래서 이런 경우와 최단거리에서는 BFS를 사용하는 것이 효과적이다.

#### DFS

상태 공간을 나타낸 트리에서 바닥에 도착할 때 까지 한 쪽 방향으로만 내려가는 방식이다.
재귀 함수로 보통 구현한다.

#### BFS

모든 분기점을 다 검사하는 방식이다.

### 예제 문제

- 백준 [15649번 N과 M (1)](https://www.acmicpc.net/problem/15649)
- 백준 [15650번 N과 M (2)](https://www.acmicpc.net/problem/15650)

# 순열

순열 (Permutation)은 수학적으로 **집합의 원소를 다른 순서로 섞는 연산**을 뜻한다.
알고리즘에서는 주로 **모든 순서를 다 시도해봐야 하는 경우**에서 순열이 사용된다.

> 서로 다른 n개의 수가 있는 수열에서 임의로 r개를 택해 일열로 배열하는 것을 뜻하며, `nPr` 로 나타낼 수 있다.
> 집합의 원소가 n개 있는 수열에서 서로 다른 순열은 N! 개가 있다.

크기가 3인 `A = [1, 2, 3]` 수열에서 순열은 (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1) 으로 6개가 존재한다.

여기서 **처음 순열**을 찾고 (1, 2, 3) 에서 **다음 순열**을 구하고 (1, 3, 2) 이 과정을 **마지막 순열**까지 반복한다면 전체 순열을 찾을 수 있다.

### 다음 순열

사전순으로 다음 순열을 찾는 방법

첫 순열은 중복이 없다면 수열의 **오름차순**이고 중복이 존재한다면 **비내림차순**이 된다.
이렇게 첫 순열부터 시작해 계속 다음 순열을 찾게 될 것인데, 해당 순열에서 마지막 순열을 찾게 된다면 한칸 줄여서 다시 시작한다.
마지막 순열은 **내림차순**이 된다.
우리는 이 다음 순열을 구하는 과정을 반복해서 순열을 구할 것이다.

### 다음 순열 알고리즘

시간 복잡도는 `n * n!`

1. `A[i-1] < A[i]` 를 만족하는 **가장 큰 i를 찾는다.**
2. `j >= 1` 이면서 `A[j] > A[i-1]`을 만족하는 **가장 큰 j를 찾는다.**
3. `A[i-1]` 과 `A[j]`를 Swap 한다.
4. `A[i]` 부터 순열을 뒤집는다.

예를 들어

`A = [7, 2, 3, 6, 5, 4, 1]` 이라는 수열이 있다고 해보자.

1번 조건에 의해서 가장 큰 i는 `A[3] = 6`을 찾을 수 있다.
그리고 2번 조건에서 j는 `A[5] = 4` 를 찾을 수 있고, `A[3]`과 `A[5]` 를 서로 swap 하면 된다.
**다음 순열을 찾는다는 것**은 해당 순열의 마지막 순열이라는 뜻이므로 다시 시작을 위해서 `A[i]`의 순서를 뒤집어준다.

### java 코드

```java
private static boolean nextPermutation(int[] arr) {
    int i = arr.length-1;
    while(i > 0 && arr[i-1] >= arr[i]) i--;
    if(i <= 0) return false;

    int j = arr.length-1;

    while(arr[j] <= arr[i-1]) j--;

    swap(arr, i-1, j);
    j = arr.length - 1;
    while(i < j) {
        swap(arr, i, j);
        i++;
        j--;
    }
    return true;
}

private static void swap(int[] arr, int index1, int index2) {
    int temp = arr[index1];
    arr[index1] = arr[index2];
    arr[index2] = temp;
}
```

### 예제 문제

- 백준 10972번 [다음 순열](https://www.acmicpc.net/problem/10972)
- 백준 10973번 [이전 순열](https://www.acmicpc.net/problem/10973)
- 백준 10974번 [모든 순열](https://www.acmicpc.net/problem/10974)
