# 연결 리스트

우리는 앞에서 [스택 자료구조]()와 [큐 자료구조]()에 대해서 알아보고 직접 **구현**해보면서 문제점들을 하나씩 파악했다.
두 자료구조 모두 **배열**을 이용했었는데, 이런 배열을 사용하면 **크기가 고정**된다는 아주 치명적인 단점이 존재했었다.
그에 반해서 **연결 리스트**는 다음과 같은 장점이 존재한다.

- 배열(리스트)의 크기가 동적으로 변할 수 있다.
- 메모리상 연속적인 공간에 할당되지 않는다.
- 미리 공간을 할당하지 않아도 된다.

그렇지만 다음과 같은 단점을도 존재한다.

- 링크 필드를 위한 추가 공간이 필요하다.
- 연산의 구현이나 사용방법이 배열에 비해 복잡하다.

## 연결 리스트의 3가지 종류

1. 단순 연결 리스트 (Singly Linked List)
2. 원형 연결 리스트 (Circular Linked List)
3. 이중 연결 리스트 (Doubly Linked List)

연결 리스트는 사용하는 용도에 따라서 3가지로 나뉠 수 있다.
**단순 연결 리스트**와 **이중 연결 리스트**는 마지막 노드가 Null을 가리키지만 **원형 연결 리스트**는 마지막 노드가 첫번째 노드를 가리킨다.

# 연결 리스트로 구현한 스택

지난 시간에 배운 **배열로 구현한 스택**과는 달리 각 요소들을 한 번에 할당하지 않고 필요할 때 마다 **동적으로**할당한다는 특징이 있다.
그리고 **연결 리스트의 특징인 노드**필드를 추가적으로 정의해야 한다.

## Node

Node는 2가지 필드로 구성된다.
때에 따라서 3가지, 4가지 n가지로 구성될 수 있지만 스택을 구현하기에는 2가지 필드면 충분하다.

1. Data Field : 실제로 우리가 저장할 데이터가 담겨있는 필드
2. Link Field : 다음에 연결될 Node의 주소를 저장하는 필드, 만약 Null이면 가장 아래에 있는 노드라는 뜻이다.

우리는 앞으로 실제 저장하고싶은 데이터를 **Data** 에 담을 것이고, 다음 노드를 해당 노드 안에 있는 Link에 저장할 것이다.

```java
class Node {
    private int data;
    private Node link;

    /* 생성자 */
    Node(Node link, int data) {
        this.data = data;
        this.link = link;
    }

    // 은닉화를 위해서 getter를 사용
    int getData() {
        return this.data;
    }
    Node getLink() {
        return link;
    }
}
```

## 연결 리스트 스택의 구성요소들

- 변수 `int data`
- 변수 `Node top`
- 메서드 `isEmpty()`
- 메서드 `push()`
- 메서드 `pop()`

여기서 알 수 있듯 연결 리스트로 구현한 스택에서는 `isFull()`메서드가 없다.
각 요소들을 한 번에 할당하지 않고 필요할 때 마다 동적으로 할당을 하는 특성이 있기 때문에 Full 한 상황이 없게 된다.

## Stack의 top 노드

지금까지 배열로 구현한 스택에서는 top 포인터가 배열의 가장 끝 index를 가리키는데에 사용되었지만, 이제 top 포인터는 노드가 될 것이고 top 노드의 Link Field가 가리키는 노드가 배열로 구현한 스택에서 말하자면 가장 위에 있는 인덱스인 샘이다.

## psuh 연산

push 연산은 top 노드가 하는 일에 대해서만 파악하면 된다.
다음 순서를 봐보자.

- A가 Stack에 push 된다.
  - top 노드가 A 노드를 가리킨다.
- B가 Stack에 push 된다.
  - B는 top이 가리키던 A 노드를 가리킨다.
  - top 노드가 B를 가리킨다.
- C가 Stack에 push 된다.
  - C는 top이 가리키던 B 노드를 가리킨다.
  - top 노드가 C를 가리킨다.

위의 순서를 보고 알 수 있는 것은 무엇인가?
**새로운 노드가 들어오면 top 노드가 이전에 가리키던 노드를 새로운 노드가 가리키고 top 노드가 새로운 노드를 가리키는 과정의 반복**을 알 수 있다.

```java
void push (int data) {
  Node node = new Node(top, data);
  top = node;

  /* 위의 2 줄을 한 줄로 축약해서 쓸 수 있다. */
  // top = new Node(top, data);
}
```

## pop 연산

pop 연산도 push와 마찬가지로 간단하게 구현될 수 있다.
또한 순서를 확인해보자.

- A, B, C가 순서대로 Stack에 저장되어 있다.
  - top 포인터는 현재 C를 가리키고 있다.
- 스택에 pop 연산이 호출된다.
  - top 포인터가 가리키는 C의 데이터를 반환한다.
  - top 포인터를 C가 가리키던 노드로 바꾼다.

또 pop 연산에서 한 가지 주의해야할 것은 isEmpty() 검사를 먼저 해줘야 한다.

```java
int pop() {
  if(isEmpty()) {
    System.out.println("Stack Empty Exception");
    return -1;
  }
  int ret = top.getData(); // 은닉화를 위해서 getter를 사용
  top = top.getLink()
  return ret;
}
```

## 전체 소스코드

```java
class Node {
    private int data;
    private Node link;

    /* 생성자 */
    Node(Node link, int data) {
        this.data = data;
        this.link = link;
    }

    int getData() {
        return this.data;
    }
    Node getLink() {
        return link;
    }
}

class ListStacak {
    private Node top;
    private int size;

    ListStack() {
        top = null;
    }

    boolean isEmpty() {
        return top == null;
    }

    void push(int data) {
        top = new Node(top, data);
    }

    int pop() {
        if(isEmpty()) {
            System.out.println("Stack Empty Exception");
            return -1;
        }
        int ret =  top.getData();
        top = top.getLink();
        return ret;
    }
}
```

# 연결 리스트로 구현한 큐

연결 리스트를 이용한 큐도 역시 Node 필드가 존재하기 때문에 필요한 메모리만 사용한다는 장점과 동시에 Node필드가 추가적인 메모리 공간을 필요로 한다는 점이 있다.
연결 리스트를 이용한 큐를 연결된 큐 (Linked Queue)라고 부른다.

연결 리스트를 사용하는 개념 자체는 스택과 비슷하다.
스택에서는 top이 다음 노드를 가리키는 포인터 역할을 수행했듯 front와 rear가 그 역할을 수행한다.

- **front** 는 큐에 가장 먼저 삽입된 노드 가리킴
- **rear** 는 큐에 가장 나중에 삽입된 노드를 가리킴

```java
class Node {
  private int data;
  private Node link;

  Node(Node link, int data) {
    this.data = data;
    this.link = link;
  }

  int getData() {
    return data;
  }

  Node getNode() {
    return link;
  }
}

class LinkedQueue {
  private Node front;
  private Node rear;

  LinkedQueue() {
    front = rear = null;

  }
}
```

## 공백 상태

공백 상태는 큐에서 말 하는 `isEmpty()`이다.
이와 반대로 포화 상태가 있는데, 연결 리스트로 구현한 스택과 마찬가지로 연결된 큐에서는 포화 상태, 즉 `isFull()`이 존재하지 않는다.

```java
boolean isEmpty() {
  return front == rear;
}
```

## enqueue

연결된 큐에서 enqueue는 2가지 경우로 나뉠 수 있다.

1. 공백 상태인 경우
2. 공백 상태가 아닌 경우

### 공백 상태인 경우

공백 상태에서 새로운 노드를 큐에 추가시킬 때는 front와 rear 모두 새로운 노드 p를 가리키게 하면 된다.

```java
void enqueue(int data) {
  if(isEmpty()) {
    Node node = new Node(null, data);
    front = node.getNode();
    rear = node.getNode();
  }
}
```

### 공백 상태가 아닌 경우

공백 상태가 아닌 경우에는 front는 바뀌지 않고 rear만 변경된다.

```java
void enqueue(int data) {
  if(!isEmpty()) {
    Node node = new Node(null, data);
    rear = node.getNode();
  }
}
```

## dequeue

```java

```
