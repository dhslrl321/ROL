# 그래프

그래프 알고리즘은 문제를 **그래프 모델로 옮기는 것**이 핵심이고
문제 풀이에서는 어떻게 효율적으로 그래프 모델로 옮길까? 를 해결하는 과정이다

### 용어 정리

- 노드, 정점 : 노드
- 간선 : 정점과 정점을 연결하는 선
- 경로 : 한 정점에서 다른 정점으로 가는 경로
- 사이클 : 정점에서 다시 정점으로 돌아오는 경로

- 단순 경로 : 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 방법
- 단순 사이클

- 방향이 있는 그래프와 방향이 없는 그래프(양방향)로 나뉠 수 있다.
> 방향이 없는 그래프는 방향이 양방향으로 있는 그래프로 바꿔야 한다.
- 루프 : 간선의 양 끝이 서로 연결된 간선 (잘 안나옴)
- 가중치 : 간선에 값이 있는 경우
- 차수 : 정점과 연결된 간선의 개수
> In-degree, Out-Degree로 나뉠 수 있다.

## 그래프 저장 방법
효율적으로 그래프를 다루기 위해서 필수적으로 사용된다.

#### 인접 행렬
- 정점의 개수가 v라고 했을 때
- v * v 이차원 배열을 만든다. `arr[i][j]`

가중치가 없을 경우 연결되면 `arr[i][j] = 1` 로 표현하고
가중치가 있을 경우 연결되면 `arr[i][j] = 가중치` 형태로 표현한다.

정점이 v 개고 간선이 e 개 라면 공간은 v^2 비용이 든다.

#### 인접 리스트

- 연결 리스트를 이용하여 구현
- `a[i] = i` 와 연결된 정점을 리스트로 포함시킨다.

인접 리스트가 인접 행렬에 비해서 압도적으로 좋으며 인접 리스트만 사용한다.

## DFS BFS

목적 : 임의의 정점에서 시작해서 연결된 모든 정점을 한 번씩 방문하는 것.

#### DFS (깊이 우선 탐색) 
재귀 함수 구현
- Stack으로 구현
> 더 이상 갈 수 없을 때 까지 갔다가 어디로 돌아가는지 기록
- 모든 정점을 방문하므로 `check[]` 배열로 방문을 했으면 1 하지 않았으면 0 으로 배열을 기록

#### BFS (너비 우선 탐색)

- Queue로 구현
